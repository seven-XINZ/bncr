/**
 * @author seven & xianyu
 * @name QBittorrentç®¡å®¶
 * @team xinz
 * @version 2.1
 * @description QBittorrentå…¨åŠŸèƒ½ç®¡ç†ï½œå¯è§†åŒ–æ“ä½œï½œæ™ºèƒ½ç¼“å­˜
 * @rule ^(qbæ“ä½œ)$
 * @priority 10000
 * @admin true
 * @disable false
 */
sysMethod.testModule(['@ctrl/qbittorrent'], { install: true });

module.exports = async s => {
    const { QBittorrent } = await import('@ctrl/qbittorrent');
    const qb = new QBittorrent({
        baseUrl: `http://ip:ç«¯å£/`,
        username: "ssh",
        password: "sshå¯†ç ",
    });

    // ç¼“å­˜ç³»ç»Ÿ
    let torrentCache = null;
    let lastRefresh = 0;
    const CACHE_TTL = 60 * 1000; // 1åˆ†é’Ÿç¼“å­˜

    try {
        while (true) {
            await showMainMenu(s);
            const command = await getInput(s, 60);
            
            if (!command) return exitWithTimeout(s);
            if (command === 'q') return exitGracefully(s);
            
            await handleCommand(s, qb, command);
        }
    } catch (err) {
        handleGlobalError(s, err);
    }

    // ======== æ ¸å¿ƒåŠŸèƒ½æ¨¡å— ========
    async function showMainMenu(s) {
        await s.reply([
            "ğŸ› ï¸ QBittorrent æ§åˆ¶ä¸­å¿ƒ",
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            "0. æ·»åŠ ç£åŠ›é“¾æ¥",
            "1. æŸ¥çœ‹åšç§åˆ—è¡¨",
            "2. å…¨éƒ¨ä»»åŠ¡åˆ—è¡¨",
            "3. ç®¡ç†æŒ‡å®šä»»åŠ¡",
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            "ğŸ“ è¾“å…¥æ•°å­—é€‰æ‹©æ“ä½œ (qé€€å‡º)"
        ].join('\n'));
    }

    async function handleCommand(s, qb, command) {
        const handlers = {
            '0': handleAddMagnet,
            '1': () => handleList(s, qb, 'seeding'),
            '2': () => handleList(s, qb, 'all'),
            '3': handleTaskManagement
        };

        return handlers[command]?.(s, qb) || invalidCommand(s);
    }

    // ======== åŠŸèƒ½å¤„ç†æ¨¡å— ========
    async function handleAddMagnet(s, qb) {
        const magnet = await getInputWithPrompt(s, [
            "ğŸ§² æ·»åŠ ç£åŠ›é“¾æ¥",
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            "è¯·è¾“å…¥ç£åŠ›é“¾æ¥æˆ–è¿”å›(u)"
        ].join('\n'), 180);

        if (magnet === 'u') return;
        if (!magnet.startsWith('magnet:')) return s.reply("âŒ æ— æ•ˆçš„ç£åŠ›é“¾æ¥æ ¼å¼");

        try {
            const result = await qb.addMagnet(magnet);
            await s.reply([
                "âœ… æ·»åŠ æˆåŠŸ",
                "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
                `è·Ÿè¸ªå“ˆå¸Œï¼š${result}`,
                "è‡ªåŠ¨è·³è½¬è‡³ä»»åŠ¡åˆ—è¡¨..."
            ].join('\n'));
            torrentCache = null; // æ¸…é™¤ç¼“å­˜
        } catch (err) {
            await s.reply([
                "âš ï¸ æ·»åŠ å¤±è´¥",
                "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
                `é”™è¯¯ä¿¡æ¯ï¼š${err.message}`
            ].join('\n'));
        }
    }

    async function handleList(s, qb, type) {
        try {
            const { torrents } = await refreshCache(qb);
            const filtered = type === 'seeding' 
                ? torrents.filter(t => t.state === 'uploading') 
                : torrents;

            await s.reply(buildListMessage(filtered, type));
        } catch (err) {
            await s.reply(buildErrorMessage('åˆ—è¡¨è·å–å¤±è´¥', err));
        }
    }

    // ======== å·¥å…·å‡½æ•°æ¨¡å— ========
    async function refreshCache(qb) {
        if (!torrentCache || Date.now() - lastRefresh > CACHE_TTL) {
            torrentCache = await qb.getAllData();
            lastRefresh = Date.now();
        }
        return torrentCache;
    }

    function buildListMessage(torrents, type) {
        if (torrents.length === 0) {
            return `ğŸ“­ å½“å‰æ²¡æœ‰${type === 'seeding' ? 'åšç§' : ''}ä»»åŠ¡`;
        }

        const header = `ğŸ“‹ ${type === 'seeding' ? 'åšç§' : 'å…¨éƒ¨'}ä»»åŠ¡ (${torrents.length}ä¸ª)`;
        const list = torrents.map((t, i) => 
            `${i+1}. ${truncate(t.name, 30)}\n   â–¸ çŠ¶æ€: ${stateIcon(t.state)} è¿›åº¦: ${t.progress}%`
        ).join('\n\n');

        return [
            header,
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            list,
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            "è¾“å…¥åºå·æŸ¥çœ‹è¯¦æƒ… (qè¿”å›)"
        ].join('\n');
    }

    function stateIcon(state) {
        const icons = {
            uploading: 'ğŸš€',
            downloading: 'â¬',
            paused: 'â¸',
            error: 'âŒ'
        };
        return `${icons[state] || 'â„¹ï¸'} ${state}`;
    }
};
